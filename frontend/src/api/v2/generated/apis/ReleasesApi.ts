/* tslint:disable */
/* eslint-disable */
/**
 * SpecFlux API
 * REST API for SpecFlux - AI-Powered Multi-Repo Development Orchestrator.  SpecFlux transforms \"vibe coding\" into disciplined, spec-driven engineering by providing: - Unified Kanban board for multi-repo project management - Automatic Claude Code agent launching with context injection - Human-in-the-loop approval workflows  ## Authentication All API endpoints (except health checks and documentation) require Firebase JWT authentication. Include the Firebase ID token in the `Authorization` header as a Bearer token.  ## Error Responses All endpoints return consistent error responses with `code`, `message`, and optional `details` fields.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  CreateReleaseRequest,
  ErrorResponse,
  Release,
  ReleaseListResponse,
  ReleaseStatus,
  UpdateReleaseRequest,
} from "../models/index";
import {
  CreateReleaseRequestFromJSON,
  CreateReleaseRequestToJSON,
  ErrorResponseFromJSON,
  ErrorResponseToJSON,
  ReleaseFromJSON,
  ReleaseToJSON,
  ReleaseListResponseFromJSON,
  ReleaseListResponseToJSON,
  ReleaseStatusFromJSON,
  ReleaseStatusToJSON,
  UpdateReleaseRequestFromJSON,
  UpdateReleaseRequestToJSON,
} from "../models/index";

export interface CreateReleaseOperationRequest {
  projectRef: string;
  createReleaseRequest: CreateReleaseRequest;
}

export interface DeleteReleaseRequest {
  projectRef: string;
  releaseRef: string;
}

export interface GetReleaseRequest {
  projectRef: string;
  releaseRef: string;
}

export interface ListReleasesRequest {
  projectRef: string;
  cursor?: string;
  limit?: number;
  sort?: ListReleasesSortEnum;
  order?: ListReleasesOrderEnum;
  status?: ReleaseStatus;
}

export interface UpdateReleaseOperationRequest {
  projectRef: string;
  releaseRef: string;
  updateReleaseRequest: UpdateReleaseRequest;
}

/**
 * ReleasesApi - interface
 *
 * @export
 * @interface ReleasesApiInterface
 */
export interface ReleasesApiInterface {
  /**
   *
   * @summary Create a new release
   * @param {string} projectRef
   * @param {CreateReleaseRequest} createReleaseRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReleasesApiInterface
   */
  createReleaseRaw(
    requestParameters: CreateReleaseOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Release>>;

  /**
   * Create a new release
   */
  createRelease(
    requestParameters: CreateReleaseOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Release>;

  /**
   *
   * @summary Delete a release
   * @param {string} projectRef
   * @param {string} releaseRef Release public ID (rel_xxx) or display key (SPEC-R1)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReleasesApiInterface
   */
  deleteReleaseRaw(
    requestParameters: DeleteReleaseRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>>;

  /**
   * Delete a release
   */
  deleteRelease(
    requestParameters: DeleteReleaseRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void>;

  /**
   *
   * @summary Get a release
   * @param {string} projectRef
   * @param {string} releaseRef Release public ID (rel_xxx) or display key (SPEC-R1)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReleasesApiInterface
   */
  getReleaseRaw(
    requestParameters: GetReleaseRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Release>>;

  /**
   * Get a release
   */
  getRelease(
    requestParameters: GetReleaseRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Release>;

  /**
   *
   * @summary List releases in a project
   * @param {string} projectRef
   * @param {string} [cursor] Base64-encoded pagination cursor
   * @param {number} [limit] Items per page (default 20, max 100)
   * @param {'created_at' | 'updated_at' | 'title'} [sort]
   * @param {'asc' | 'desc'} [order]
   * @param {ReleaseStatus} [status]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReleasesApiInterface
   */
  listReleasesRaw(
    requestParameters: ListReleasesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ReleaseListResponse>>;

  /**
   * List releases in a project
   */
  listReleases(
    requestParameters: ListReleasesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ReleaseListResponse>;

  /**
   *
   * @summary Update a release
   * @param {string} projectRef
   * @param {string} releaseRef Release public ID (rel_xxx) or display key (SPEC-R1)
   * @param {UpdateReleaseRequest} updateReleaseRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReleasesApiInterface
   */
  updateReleaseRaw(
    requestParameters: UpdateReleaseOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Release>>;

  /**
   * Update a release
   */
  updateRelease(
    requestParameters: UpdateReleaseOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Release>;
}

/**
 *
 */
export class ReleasesApi
  extends runtime.BaseAPI
  implements ReleasesApiInterface
{
  /**
   * Create a new release
   */
  async createReleaseRaw(
    requestParameters: CreateReleaseOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Release>> {
    if (requestParameters["projectRef"] == null) {
      throw new runtime.RequiredError(
        "projectRef",
        'Required parameter "projectRef" was null or undefined when calling createRelease().',
      );
    }

    if (requestParameters["createReleaseRequest"] == null) {
      throw new runtime.RequiredError(
        "createReleaseRequest",
        'Required parameter "createReleaseRequest" was null or undefined when calling createRelease().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/projects/{projectRef}/releases`;
    urlPath = urlPath.replace(
      `{${"projectRef"}}`,
      encodeURIComponent(String(requestParameters["projectRef"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateReleaseRequestToJSON(
          requestParameters["createReleaseRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ReleaseFromJSON(jsonValue),
    );
  }

  /**
   * Create a new release
   */
  async createRelease(
    requestParameters: CreateReleaseOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Release> {
    const response = await this.createReleaseRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Delete a release
   */
  async deleteReleaseRaw(
    requestParameters: DeleteReleaseRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["projectRef"] == null) {
      throw new runtime.RequiredError(
        "projectRef",
        'Required parameter "projectRef" was null or undefined when calling deleteRelease().',
      );
    }

    if (requestParameters["releaseRef"] == null) {
      throw new runtime.RequiredError(
        "releaseRef",
        'Required parameter "releaseRef" was null or undefined when calling deleteRelease().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/projects/{projectRef}/releases/{releaseRef}`;
    urlPath = urlPath.replace(
      `{${"projectRef"}}`,
      encodeURIComponent(String(requestParameters["projectRef"])),
    );
    urlPath = urlPath.replace(
      `{${"releaseRef"}}`,
      encodeURIComponent(String(requestParameters["releaseRef"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a release
   */
  async deleteRelease(
    requestParameters: DeleteReleaseRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.deleteReleaseRaw(requestParameters, initOverrides);
  }

  /**
   * Get a release
   */
  async getReleaseRaw(
    requestParameters: GetReleaseRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Release>> {
    if (requestParameters["projectRef"] == null) {
      throw new runtime.RequiredError(
        "projectRef",
        'Required parameter "projectRef" was null or undefined when calling getRelease().',
      );
    }

    if (requestParameters["releaseRef"] == null) {
      throw new runtime.RequiredError(
        "releaseRef",
        'Required parameter "releaseRef" was null or undefined when calling getRelease().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/projects/{projectRef}/releases/{releaseRef}`;
    urlPath = urlPath.replace(
      `{${"projectRef"}}`,
      encodeURIComponent(String(requestParameters["projectRef"])),
    );
    urlPath = urlPath.replace(
      `{${"releaseRef"}}`,
      encodeURIComponent(String(requestParameters["releaseRef"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ReleaseFromJSON(jsonValue),
    );
  }

  /**
   * Get a release
   */
  async getRelease(
    requestParameters: GetReleaseRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Release> {
    const response = await this.getReleaseRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * List releases in a project
   */
  async listReleasesRaw(
    requestParameters: ListReleasesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ReleaseListResponse>> {
    if (requestParameters["projectRef"] == null) {
      throw new runtime.RequiredError(
        "projectRef",
        'Required parameter "projectRef" was null or undefined when calling listReleases().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["cursor"] != null) {
      queryParameters["cursor"] = requestParameters["cursor"];
    }

    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }

    if (requestParameters["sort"] != null) {
      queryParameters["sort"] = requestParameters["sort"];
    }

    if (requestParameters["order"] != null) {
      queryParameters["order"] = requestParameters["order"];
    }

    if (requestParameters["status"] != null) {
      queryParameters["status"] = requestParameters["status"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/projects/{projectRef}/releases`;
    urlPath = urlPath.replace(
      `{${"projectRef"}}`,
      encodeURIComponent(String(requestParameters["projectRef"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ReleaseListResponseFromJSON(jsonValue),
    );
  }

  /**
   * List releases in a project
   */
  async listReleases(
    requestParameters: ListReleasesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ReleaseListResponse> {
    const response = await this.listReleasesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Update a release
   */
  async updateReleaseRaw(
    requestParameters: UpdateReleaseOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Release>> {
    if (requestParameters["projectRef"] == null) {
      throw new runtime.RequiredError(
        "projectRef",
        'Required parameter "projectRef" was null or undefined when calling updateRelease().',
      );
    }

    if (requestParameters["releaseRef"] == null) {
      throw new runtime.RequiredError(
        "releaseRef",
        'Required parameter "releaseRef" was null or undefined when calling updateRelease().',
      );
    }

    if (requestParameters["updateReleaseRequest"] == null) {
      throw new runtime.RequiredError(
        "updateReleaseRequest",
        'Required parameter "updateReleaseRequest" was null or undefined when calling updateRelease().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/projects/{projectRef}/releases/{releaseRef}`;
    urlPath = urlPath.replace(
      `{${"projectRef"}}`,
      encodeURIComponent(String(requestParameters["projectRef"])),
    );
    urlPath = urlPath.replace(
      `{${"releaseRef"}}`,
      encodeURIComponent(String(requestParameters["releaseRef"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: UpdateReleaseRequestToJSON(
          requestParameters["updateReleaseRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ReleaseFromJSON(jsonValue),
    );
  }

  /**
   * Update a release
   */
  async updateRelease(
    requestParameters: UpdateReleaseOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Release> {
    const response = await this.updateReleaseRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}

/**
 * @export
 */
export const ListReleasesSortEnum = {
  CreatedAt: "created_at",
  UpdatedAt: "updated_at",
  Title: "title",
} as const;
export type ListReleasesSortEnum =
  (typeof ListReleasesSortEnum)[keyof typeof ListReleasesSortEnum];
/**
 * @export
 */
export const ListReleasesOrderEnum = {
  Asc: "asc",
  Desc: "desc",
} as const;
export type ListReleasesOrderEnum =
  (typeof ListReleasesOrderEnum)[keyof typeof ListReleasesOrderEnum];
