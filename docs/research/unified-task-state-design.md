# Unified Task State Design

**Status:** Proposal
**Date:** November 2024
**References:**
- [Anthropic - Effective Harnesses for Long-Running Agents](https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents)
- [Claude 4.x Best Practices](https://platform.claude.com/docs/en/build-with-claude/prompt-engineering/claude-4-best-practices)

---

## The Problem

AI agents face two distinct context challenges:

### Challenge 1: Inter-Task Context (Already Solved by SpecFlux)

When multiple tasks depend on each other, downstream tasks need to know what upstream tasks produced.

```mermaid
flowchart LR
    subgraph "Task #101"
        A1[Agent works]
        A2[Produces output]
    end

    subgraph "Task #102"
        B1[Needs #101's output]
        B2[Agent works]
    end

    A2 -->|"Chain Output"| B1

    style A2 fill:#4CAF50
    style B1 fill:#4CAF50
```

**Current Solution:** Chain Outputs - summaries passed between tasks.

### Challenge 2: Intra-Task Context (NOT Solved Yet)

When a single task requires multiple sessions (context window resets), the agent loses memory of previous work.

```mermaid
flowchart TD
    subgraph "Task #101 - JWT Service"
        subgraph "Session 1"
            S1A[Agent starts fresh]
            S1B[Works on feature]
            S1C[Context window fills up]
        end

        S1C -->|"Context Resets!"| S2A

        subgraph "Session 2"
            S2A[Agent starts fresh]
            S2B["No memory of Session 1"]
            S2C[May redo work or miss bugs]
        end
    end

    style S1C fill:#F44336
    style S2B fill:#F44336
```

**Current Gap:** No mechanism for session-to-session continuity within a single task.

---

## The Solution: Unified Task State

Instead of separate files for different purposes, maintain **one living document** per task that serves all needs:

```mermaid
flowchart TB
    subgraph "Unified Task State File"
        direction TB
        CTX[Static Context<br/>PRD, Epic, Task Description]
        INPUT[Chain Inputs<br/>From upstream tasks]
        PROGRESS[Progress Log<br/>Updated each session]
        OUTPUT[Chain Output<br/>Finalized when complete]

        CTX --> INPUT --> PROGRESS --> OUTPUT
    end

    style CTX fill:#E3F2FD
    style INPUT fill:#FFF3E0
    style PROGRESS fill:#E8F5E9
    style OUTPUT fill:#F3E5F5
```

### How It Works

```mermaid
sequenceDiagram
    participant SF as SpecFlux
    participant File as task-101-state.md
    participant Agent as Claude Agent

    Note over SF,Agent: Task Creation
    SF->>File: Create with Static Context + Chain Inputs

    Note over SF,Agent: Session 1
    Agent->>File: Read current state
    Agent->>Agent: Work on task
    Agent->>File: Append to Progress Log
    Note over Agent: Context window fills up

    Note over SF,Agent: Session 2
    Agent->>File: Read current state (including Session 1 progress)
    Agent->>Agent: Continue where left off
    Agent->>File: Append to Progress Log

    Note over SF,Agent: Task Completion
    Agent->>File: Finalize Chain Output section
    SF->>SF: Extract Chain Output for downstream tasks
```

---

## File Structure

### Single File Per Task

```
orchestrator/devflow/task-states/
├── task-101-state.md    # JWT Service
├── task-102-state.md    # API Endpoints
├── task-103-state.md    # Login Form
└── ...
```

### File Format

```markdown
# Task #101: JWT Service - State

## 1. Static Context (Generated by SpecFlux at task creation)

**PRD:** ../2-planning/user-auth.md
**Epic:** User Authentication System
**Repository:** backend
**Agent:** backend-developer

### Task Description
Implement JWT token generation and verification service.

### Acceptance Criteria
- [ ] Generate JWT on successful login
- [ ] Validate JWT on protected routes
- [ ] Implement refresh token rotation
- [ ] Add tests with 90%+ coverage

---

## 2. Chain Inputs (From completed upstream tasks)

### From Task #100: Database Schema
> Users table created with columns:
> - id (UUID, primary key)
> - email (VARCHAR, unique)
> - password_hash (VARCHAR)
> - created_at (TIMESTAMP)

---

## 3. Progress Log (Updated by agent each session)

### Session 1 - 2024-11-26 14:30
**What I did:**
- Created `src/auth/jwt.service.ts` with `generateToken()` method
- Added jsonwebtoken dependency

**Issues encountered:**
- TypeScript types for jsonwebtoken not found

**Current state:**
- generateToken() implemented but not tested
- verifyToken() not started

**Next steps:**
- Install @types/jsonwebtoken
- Implement verifyToken()
- Write unit tests

### Session 2 - 2024-11-26 15:45
**What I did:**
- Fixed TypeScript types issue
- Implemented verifyToken() with signature validation
- Added 8 unit tests, all passing

**Issues encountered:**
- None

**Current state:**
- Core functionality complete
- Unit tests passing

**Next steps:**
- Add integration test with HTTP request
- Update acceptance criteria checkboxes
- Finalize chain output

---

## 4. Chain Output (Finalized when task is marked complete)

### Summary
Implemented JWT authentication service with token generation and verification.

### Files Created/Modified
- `src/auth/jwt.service.ts` - Main service (new)
- `src/auth/jwt.service.test.ts` - Unit tests (new)
- `package.json` - Added jsonwebtoken dependency

### API Contract
```typescript
class JWTService {
  generateToken(userId: string, role?: string): string
  verifyToken(token: string): TokenPayload | null
  refreshToken(oldToken: string): string
}

interface TokenPayload {
  userId: string;
  role: string;
  exp: number;
}
```

### Configuration Required
```env
JWT_SECRET=your-secret-key-min-32-chars
JWT_EXPIRY=15m
JWT_REFRESH_EXPIRY=7d
```

### Integration Notes for Downstream Tasks
- Import: `import { jwtService } from '../auth/jwt.service'`
- Use in middleware: `const payload = jwtService.verifyToken(token)`
- Token format: Bearer token in Authorization header
- Returns null for invalid/expired tokens (check before proceeding)
```

---

## Lifecycle Visualization

```mermaid
stateDiagram-v2
    [*] --> Created: SpecFlux creates task

    Created --> SessionActive: Agent starts

    state SessionActive {
        [*] --> ReadState: Read task-state.md
        ReadState --> Work: Understand context & progress
        Work --> UpdateProgress: Append progress log
        UpdateProgress --> [*]: Session ends
    }

    SessionActive --> SessionActive: Context resets, new session
    SessionActive --> Complete: All criteria met

    Complete --> [*]: Chain Output extracted
```

---

## Data Flow Across Multiple Tasks

```mermaid
flowchart TB
    subgraph "Task #100: DB Schema"
        T100_CTX[Context]
        T100_PROG[Progress]
        T100_OUT[Chain Output:<br/>Users table with email, password_hash]
    end

    subgraph "Task #101: JWT Service"
        T101_CTX[Context]
        T101_IN[Chain Input: #100's output]
        T101_PROG[Progress:<br/>Session 1: Created generateToken<br/>Session 2: Added verifyToken]
        T101_OUT[Chain Output:<br/>JWTService API contract]
    end

    subgraph "Task #102: Auth Endpoints"
        T102_CTX[Context]
        T102_IN[Chain Inputs: #100 + #101]
        T102_PROG[Progress]
        T102_OUT[Chain Output]
    end

    T100_OUT -->|"Flows to"| T101_IN
    T100_OUT -->|"Flows to"| T102_IN
    T101_OUT -->|"Flows to"| T102_IN

    style T100_OUT fill:#4CAF50
    style T101_IN fill:#FFF3E0
    style T101_OUT fill:#4CAF50
    style T102_IN fill:#FFF3E0
```

---

## Agent Session Protocol

Every agent session follows this protocol (injected into agent context):

```mermaid
flowchart TD
    A[Session Starts] --> B[Read task-state.md]
    B --> C{Has Progress Log?}

    C -->|No| D[First session - start fresh]
    C -->|Yes| E[Read previous sessions]

    E --> F[Understand current state]
    F --> G[Identify next steps]

    D --> H[Check Chain Inputs]
    G --> H

    H --> I[Begin work]
    I --> J[Make progress]
    J --> K[Append to Progress Log]
    K --> L{Task complete?}

    L -->|No| M[End session]
    L -->|Yes| N[Finalize Chain Output]
    N --> O[Mark task complete]

    style B fill:#E3F2FD
    style K fill:#E8F5E9
    style N fill:#F3E5F5
```

### Protocol Instructions (Injected to Agent)

```markdown
## Session Startup Protocol

1. **Read State First**
   - Open and read the entire task-state.md file
   - Understand the static context (what to build)
   - Review chain inputs (what upstream provided)
   - Read ALL progress log entries (what's been done)

2. **Verify Environment**
   - Run `pwd` to confirm correct directory
   - Run `git status` to see current state
   - Start dev server if needed

3. **Plan This Session**
   - Identify the next incomplete item from "Next steps"
   - Focus on ONE feature per session
   - Don't try to complete everything at once

4. **Work Incrementally**
   - Make small, testable changes
   - Commit frequently with clear messages
   - Test before moving on

5. **Update Progress Before Ending**
   - Append a new session entry to Progress Log
   - Document what you did, issues, current state, next steps
   - This is critical for the next session!

6. **Finalize If Complete**
   - Update acceptance criteria checkboxes
   - Write the Chain Output section
   - This helps downstream tasks
```

---

## Comparison: Before vs After

### Before (Current SpecFlux)

```mermaid
flowchart LR
    subgraph "Task Start"
        PRD[PRD.md]
        EPIC[Epic.md]
        TASK[Task description]
        CHAIN_IN[Chain inputs]
    end

    subgraph "Task Execution"
        AGENT[Agent works]
        LOST[Progress lost on reset]
    end

    subgraph "Task End"
        CHAIN_OUT[Chain output.md]
    end

    PRD --> AGENT
    EPIC --> AGENT
    TASK --> AGENT
    CHAIN_IN --> AGENT
    AGENT --> LOST
    AGENT --> CHAIN_OUT

    style LOST fill:#F44336
```

**Problems:**
- Progress lost when context resets
- No session continuity
- Agent may redo work

### After (Unified Task State)

```mermaid
flowchart LR
    subgraph "Task State File"
        CTX[Static Context]
        IN[Chain Inputs]
        PROG[Progress Log]
        OUT[Chain Output]
    end

    subgraph "Session N"
        READ[Read full state]
        WORK[Work with full context]
        UPDATE[Update progress]
    end

    CTX --> READ
    IN --> READ
    PROG --> READ
    READ --> WORK
    WORK --> UPDATE
    UPDATE --> PROG
    UPDATE --> OUT

    style PROG fill:#4CAF50
```

**Benefits:**
- Progress preserved across sessions
- Agent always has full context
- Clean handoff to downstream tasks

---

## Implementation in SpecFlux

### When Task is Created

```typescript
// SpecFlux generates initial task state file
function createTaskState(task: Task, epic: Epic, prd: PRD, chainInputs: ChainOutput[]) {
  const content = `
# Task #${task.id}: ${task.title} - State

## 1. Static Context
**PRD:** ${prd.path}
**Epic:** ${epic.title}
**Repository:** ${task.repository}
**Agent:** ${task.agent}

### Task Description
${task.description}

### Acceptance Criteria
${task.acceptanceCriteria.map(c => `- [ ] ${c}`).join('\n')}

---

## 2. Chain Inputs
${chainInputs.map(ci => `
### From Task #${ci.taskId}: ${ci.taskTitle}
> ${ci.summary}
`).join('\n')}

---

## 3. Progress Log

(Agent will append entries here)

---

## 4. Chain Output

(Agent will finalize when task is complete)
`;

  writeFile(`devflow/task-states/task-${task.id}-state.md`, content);
}
```

### When Task is Started

```typescript
// Inject task state file path into agent context
function launchAgent(task: Task) {
  const stateFile = `devflow/task-states/task-${task.id}-state.md`;

  // Agent receives instructions to read this file first
  spawnClaude({
    context: `
      Read ${stateFile} completely before starting.
      Follow the Session Startup Protocol.
      Update the Progress Log before ending your session.
    `,
    workingDirectory: task.repository.path
  });
}
```

### When Task Completes

```typescript
// Extract chain output for downstream tasks
function extractChainOutput(task: Task): ChainOutput {
  const stateFile = readFile(`devflow/task-states/task-${task.id}-state.md`);
  const chainOutputSection = parseSection(stateFile, '## 4. Chain Output');

  return {
    taskId: task.id,
    taskTitle: task.title,
    summary: chainOutputSection,
    timestamp: new Date()
  };
}
```

---

## Summary

The Unified Task State approach:

1. **Combines** context injection, chain inputs, progress tracking, and chain outputs into **one file**
2. **Solves** both inter-task (dependency handoffs) and intra-task (session continuity) problems
3. **Enables** agents to pick up exactly where they left off after context resets
4. **Maintains** clean handoffs to downstream tasks through the Chain Output section
5. **Follows** the patterns proven effective by Anthropic's research on long-running agents

This is an evolution of SpecFlux's existing approach, not a replacement. It extends our "chain outputs" concept to also handle session continuity within a single task.

---

## Claude 4.x Best Practices Integration

The Claude 4 documentation provides critical insights that validate and extend our design.

### Key Insight: Multi-Window Workflows

From the docs:
> "Use initial context windows for framework setup (tests, scripts), then iterate on structured task lists"
> "Save your current progress and state to memory before the context window refreshes"

**This directly validates our Unified Task State approach.** Claude 4 is designed for exactly this pattern - structured state tracking across context windows.

### Recommended State Tracking Strategy

The docs recommend:
- **JSON** for structured data (test results, feature checklists)
- **Unstructured text** for progress notes
- **Git** for versioning across sessions

```mermaid
flowchart LR
    subgraph "State Tracking"
        JSON[JSON<br/>Feature checklist<br/>Test results]
        TEXT[Text<br/>Progress log<br/>Session notes]
        GIT[Git<br/>Code changes<br/>Commits]
    end

    subgraph "Task State File"
        CHECKLIST[Acceptance Criteria<br/>as JSON array]
        PROGRESS[Progress Log<br/>as markdown]
        COMMITS[Git commit refs<br/>for rollback]
    end

    JSON --> CHECKLIST
    TEXT --> PROGRESS
    GIT --> COMMITS
```

### Updated File Format with Claude 4 Patterns

```markdown
# Task #101: JWT Service - State

## 1. Static Context
(Same as before - PRD, Epic, Task Description)

## 2. Chain Inputs
(Same as before - from upstream tasks)

## 3. Feature Checklist (JSON for structured tracking)

```json
{
  "features": [
    {
      "id": "jwt-1",
      "description": "generateToken() creates valid JWT",
      "passes": false,
      "tested_at": null
    },
    {
      "id": "jwt-2",
      "description": "verifyToken() validates signature",
      "passes": true,
      "tested_at": "2024-11-26T15:45:00Z"
    }
  ],
  "overall_progress": "40%"
}
```

## 4. Progress Log (Unstructured text for session notes)

### Session 1 - 2024-11-26 14:30
(Detailed session notes as before)

## 5. Git History (References for rollback)

- `abc123` - feat: add generateToken method
- `def456` - feat: add verifyToken with signature validation
- `ghi789` - test: add unit tests for JWT service

## 6. Chain Output
(Finalized when complete)
```

---

## Claude 4 Agent Prompting Principles

### 1. Explicit Action Directives

Claude 4 requires explicit instructions to take action. Weak vs Strong:

| Weak (Avoid) | Strong (Use) |
|--------------|--------------|
| "Can you suggest changes?" | "Change this function to improve performance." |
| "Maybe add some tests?" | "Write unit tests for all public methods." |
| "Consider adding error handling" | "Add try/catch blocks with specific error types." |

**SpecFlux should inject action-oriented language:**

```markdown
## Agent Instructions

DO NOT just suggest changes. IMPLEMENT them directly.
DO NOT ask for permission. Make the changes and explain what you did.
DO NOT leave TODOs. Complete each feature before moving on.
```

### 2. Contextual Framing (Explain WHY)

Instead of just rules, explain the reasoning:

```markdown
## Why This Matters

You MUST read the task-state.md file first because:
- It contains progress from previous sessions that you don't remember
- Skipping this will cause you to redo work or miss bugs
- The feature checklist tells you exactly what's incomplete

You MUST update the progress log before ending because:
- The next session (which might be you after context reset) needs this
- Without it, work will be lost and repeated
- This is how multi-window workflows succeed
```

### 3. Minimize Overengineering

From Claude 4 docs:
> "Add prompts emphasizing simplicity—avoid unnecessary abstractions, extra files, or hypothetical flexibility beyond current requirements."

**Inject into agent context:**

```markdown
## Code Quality Rules

- Implement ONLY what the acceptance criteria require
- Do NOT add "nice to have" features
- Do NOT create abstractions for single-use code
- Do NOT add configuration for hypothetical future needs
- Keep solutions simple and direct
- Three similar lines of code is better than a premature abstraction
```

### 4. Code Exploration Before Edits

From Claude 4 docs:
> "ALWAYS read and understand relevant files before proposing code edits."

**Add to session protocol:**

```markdown
## Before Writing Any Code

1. Read existing files in the area you'll modify
2. Understand the current patterns and conventions
3. Check for similar implementations to follow
4. NEVER assume file contents - always read first
5. NEVER make claims about code without investigating
```

### 5. Avoid Test-Driven Hardcoding

From Claude 4 docs:
> "Implement general-purpose solutions that work for all valid inputs, not just passing specific tests."

**Add to agent instructions:**

```markdown
## Testing Philosophy

- Write code that solves the general problem, not just the test cases
- If tests pass but the solution is hacky, refactor before marking complete
- Add edge case tests beyond the acceptance criteria
- A passing test suite with hardcoded values is a FAILURE
```

---

## Verification Tools Integration

Claude 4 docs emphasize:
> "Implement testing mechanisms (Playwright, computer use) for autonomous validation"

### MCP Server Configuration

SpecFlux should auto-configure verification tools:

```json
{
  "mcpServers": {
    "playwright": {
      "command": "npx",
      "args": ["-y", "@anthropic/mcp-playwright"],
      "description": "Browser automation for E2E testing"
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "description": "Create PRs, issues automatically"
    }
  }
}
```

### Verification Protocol

```mermaid
flowchart TD
    A[Feature Implemented] --> B{Has UI Component?}
    B -->|Yes| C[Use Playwright to verify visually]
    B -->|No| D[Run unit tests]
    C --> E{Tests Pass?}
    D --> E
    E -->|Yes| F[Update feature checklist: passes=true]
    E -->|No| G[Debug and fix]
    G --> A

    style C fill:#E8F5E9
    style F fill:#4CAF50
```

**Agent instruction for verification:**

```markdown
## Verification Requirements

For EVERY feature you implement:
1. Write automated tests (unit or integration)
2. Run the tests and confirm they pass
3. For UI features, use Playwright to verify visually
4. Only mark a feature as "passes: true" after ALL verification
5. If you cannot verify, explain why in the progress log
```

---

## Updated Session Protocol (Claude 4 Optimized)

```markdown
## Session Startup Protocol (FOLLOW EXACTLY)

### Phase 1: Orientation (DO THIS FIRST)
1. Run `pwd` to verify correct directory
2. Read the ENTIRE task-state.md file
3. Run `git log --oneline -10` to see recent history
4. Run `git status` to check working state

### Phase 2: Understanding (BEFORE ANY CODE)
5. Review the feature checklist - identify incomplete features
6. Read previous session notes in Progress Log
7. Read relevant source files you'll modify (NEVER assume contents)
8. Check for existing patterns to follow

### Phase 3: Planning (FOCUS ON ONE FEATURE)
9. Pick the NEXT incomplete feature from checklist
10. Plan your approach (spend 2-3 minutes thinking)
11. Identify files you'll create or modify

### Phase 4: Implementation (ACTION-ORIENTED)
12. Start dev server if needed
13. IMPLEMENT the feature directly (don't just suggest)
14. Write tests as you go
15. Commit with descriptive messages

### Phase 5: Verification (REQUIRED)
16. Run all tests - they MUST pass
17. For UI features, verify visually with Playwright
18. Update feature checklist: set passes=true only if verified

### Phase 6: Handoff (BEFORE SESSION ENDS)
19. Append to Progress Log:
    - What you did this session
    - Any issues encountered
    - Current state of the codebase
    - Clear next steps
20. If task complete, finalize Chain Output section
21. Commit all changes including task-state.md updates
```

---

## Summary: Claude 4 Alignment

| Claude 4 Recommendation | SpecFlux Implementation |
|-------------------------|------------------------|
| Structured state tracking | Unified Task State file with JSON + text |
| Multi-window workflows | Progress Log persists across sessions |
| Explicit action directives | Action-oriented agent instructions |
| Contextual framing | Explain WHY in all instructions |
| Minimize overengineering | Simplicity rules in agent context |
| Read before edit | Mandatory code exploration phase |
| Verification tools | Playwright MCP integration |
| Avoid hardcoding | Testing philosophy guidelines |

The Claude 4 best practices **validate our approach** and provide specific prompting patterns to make agents more effective within the Unified Task State framework.
